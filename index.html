<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Online Universal Timer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css" rel="stylesheet">
  <style>
    /* ... Your CSS here ... */
    .timer-section:not(.visible) { display: none; }
    /* Other styles unchanged */
  </style>
</head>
<body>
  <main>
    <select id="timerType" aria-label="Timer Type">
      <option value="">-- Select Timer Type --</option>
      <option value="stopwatch" data-tip="Counts up from zero.">Stopwatch</option>
      <option value="hiit" data-tip="High-Intensity Interval Training: alternating work/rest intervals for set rounds.">HIIT Interval Timer</option>
      <option value="pomodoro" data-tip="Pomodoro: work/break cycles for productivity.">Pomodoro Timer</option>
      <option value="chess" data-tip="Chess clock: two timers, alternate between players.">Chess Clock</option>
      <option value="event" data-tip="Countdown to a specific date/time.">Event Countdown</option>
      <option value="tabata" data-tip="Tabata: intervals of work and rest for a set number of rounds.">Tabata Timer</option>
      <option value="custom" data-tip="Enter a custom interval pattern, e.g. 10,20,10.">Custom Interval Timer</option>
      <option value="presentation" data-tip="Countdown for presentations with minutes input.">Presentation Timer</option>
      <option value="breathing" data-tip="Guided breathing cycles: inhale, hold, exhale.">Breathing Timer</option>
      <option value="soundloop" data-tip="Repeating sound at set intervals.">Repeating Sound Timer</option>
    </select>
    <span id="timerDesc" style="display:block;min-height:1.8em;margin:0.5em 0 1.2em 0;color:var(--primary-light);font-size:1em;"></span>
    <div id="presetBar"></div>
    <div class="progress-bar-wrap" id="progressWrap" style="display:none;">
      <div class="progress-bar-inner" id="progressInner"></div>
    </div>
    <div id="timerDisplay" class="timer-section visible" role="status" aria-live="polite">Select a timer type to begin</div>
    <form id="timerControls" class="timer-section" aria-label="Timer Controls"></form>
    <div id="feedback" class="feedback" aria-live="polite"></div>
  </main>

  <script>
    // --- TIMER MODE DESCRIPTIONS ---
    const timerDescriptions = {
      countdown: "Simple countdown. Enter minutes and/or seconds.",
      stopwatch: "Counts up from zero. Can pause/resume.",
      hiit: "HIIT: Alternate work/rest intervals for set rounds. Save presets for favorite workouts.",
      pomodoro: "Pomodoro: Work/break cycles for focus. Save favorite settings.",
      chess: "Chess clock: Two timers, alternate between players.",
      event: "Countdown to a specific date/time.",
      tabata: "Tabata: Intervals of work/rest for set rounds.",
      custom: "Custom intervals: e.g. 10,5,10 (seconds per interval).",
      presentation: "Presentation: Countdown for a presentation.",
      breathing: "Guided breathing: inhale, hold, exhale.",
      soundloop: "Repeating sound at set intervals.",
    };

    // --- TOOLTIP ENHANCEMENT ---
    // Show option descriptions as user hovers/selects
    const timerTypeSelect = document.getElementById('timerType');
    const timerDesc = document.getElementById('timerDesc');
    timerTypeSelect.addEventListener('change', () => {
      const val = timerTypeSelect.value;
      timerDesc.textContent = timerDescriptions[val] || '';
    });
    timerTypeSelect.addEventListener('mouseover', e => {
      if (e.target.tagName === 'OPTION') {
        timerDesc.textContent = e.target.dataset.tip || '';
      }
    });
    timerTypeSelect.addEventListener('mouseout', e => {
      const val = timerTypeSelect.value;
      timerDesc.textContent = timerDescriptions[val] || '';
    });

    // --- UTILITY FUNCTIONS ---
    function parseFlexibleTime(str) {
      // Accepts "90" or "1:30" or "2m 15s" or "1m" or "45s"
      str = (str + '').trim();
      if (!str) return NaN;
      if (/^\d+$/.test(str)) return parseInt(str, 10);
      let match = str.match(/^(\d+):(\d+)$/); // "m:s"
      if (match) return parseInt(match[1],10)*60 + parseInt(match[2],10);
      match = str.match(/^(?:(\d+)m)?\s*(?:(\d+)s)?$/);
      if (match) return (parseInt(match[1]||0,10)*60)+(parseInt(match[2]||0,10));
      match = str.match(/^(\d+)m(?:in)?$/i);
      if (match) return parseInt(match[1],10)*60;
      match = str.match(/^(\d+)s(?:ec)?$/i);
      if (match) return parseInt(match[1],10);
      return NaN;
    }
    function formatTime(s) {
      s = Math.max(0, Math.round(s));
      let m = Math.floor(s/60), sec = s%60;
      return m > 0 ? `${m}:${sec.toString().padStart(2,'0')}` : `${sec}s`;
    }
    function addIncDec(input, big, small) {
      // Add +/- buttons for number input
      if (input.type !== "number") return;
      const wrap = document.createElement('span');
      wrap.style.display = "inline-flex";
      wrap.style.alignItems = "center";
      wrap.appendChild(input);
      const up = document.createElement('button'); up.type = "button"; up.innerHTML = "+"; up.tabIndex = -1;
      const down = document.createElement('button'); down.type = "button"; down.innerHTML = "-"; down.tabIndex = -1;
      up.onclick = () => input.value = (+input.value||0) + (big||1);
      down.onclick = () => input.value = Math.max((+input.value||0)-(big||1), input.min ? +input.min : 0);
      wrap.appendChild(up); wrap.appendChild(down);
      input.parentNode && input.parentNode.replaceChild(wrap, input);
      return wrap;
    }
    function showFeedback(msg, isErr) {
      feedback.textContent = msg || '';
      feedback.style.color = isErr ? "crimson" : "";
    }
    function showProgress(p) {
      progressWrap.style.display = "";
      progressInner.style.width = `${(p*100).toFixed(1)}%`;
    }
    function hideProgress() {
      progressWrap.style.display = "none";
    }
    function playBeep() {
      try {
        let ctx = new (window.AudioContext||window.webkitAudioContext)();
        let o = ctx.createOscillator();
        o.type = "triangle"; o.frequency.value = 880;
        o.connect(ctx.destination); o.start();
        setTimeout(()=>{o.stop();ctx.close();},180);
      } catch(e) {}
    }
    function vibrate(ms) {
      if (navigator.vibrate) navigator.vibrate(ms || 150);
    }
    function notify(msg) {
      if (window.Notification && Notification.permission === "granted") {
        new Notification(msg);
      }
    }
    function finishActions(msg) {
      playBeep(); vibrate();
      if (msg) showFeedback(msg);
    }

    const timerDisplay = document.getElementById('timerDisplay');
    const timerControls = document.getElementById('timerControls');
    const feedback = document.getElementById('feedback');
    const progressWrap = document.getElementById('progressWrap');
    const progressInner = document.getElementById('progressInner');
    let timer = null, chess = null;
    let pauseState = { paused: false, remain: 0, context: null };

    function clearTimer() {
      if (timer) clearInterval(timer);
      timer = null;
      hideProgress();
      pauseState.paused = false;
    }
    function setupPauseResume(getRemain, setRemain, onPause, onResume) {
      // getRemain: function returning remaining seconds
      // setRemain: function to set remaining seconds in pause/resume
      const pauseBtn = document.createElement('button');
      pauseBtn.id = "pauseBtn";
      pauseBtn.innerHTML = '<i class="fa fa-pause"></i> Pause';
      pauseBtn.onclick = () => {
        if (!pauseState.paused) {
          clearInterval(timer);
          pauseState.paused = true;
          pauseState.remain = getRemain();
          pauseBtn.innerHTML = '<i class="fa fa-play"></i> Resume';
          if (onPause) onPause();
        } else {
          pauseState.paused = false;
          setRemain(pauseState.remain);
          pauseBtn.innerHTML = '<i class="fa fa-pause"></i> Pause';
          if (onResume) onResume();
        }
      };
      timerControls.appendChild(pauseBtn);
    }

    // --- TIMER RENDERERS ---
    function renderCountdown() {
      timerControls.innerHTML = '';
      timerControls.classList.add('visible');
      clearTimer();
      hideProgress();
      const label = document.createElement('label'); label.textContent = "Duration (e.g. 1:30 or 90s):";
      const input = document.createElement('input'); input.type = "text"; input.placeholder = "e.g. 90, 1:30, 2m 15s";
      addIncDec(input, 5, 1);
      const startBtn = document.createElement('button'); startBtn.innerHTML = '<i class="fa fa-play"></i>Start';
      timerControls.append(label, input, startBtn);
      let total = 0, remain = 0;
      startBtn.onclick = (e) => {
        e.preventDefault();
        let time = parseFlexibleTime(input.value);
        if (isNaN(time) || time < 1) return showFeedback('Please enter a valid time.', true);
        showFeedback('');
        total = time; remain = time;
        clearTimer();
        let lastRemain = remain;
        timerDisplay.textContent = formatTime(remain);
        showProgress(1.0);
        timer = setInterval(() => {
          if (pauseState.paused) return;
          remain--;
          timerDisplay.textContent = formatTime(remain);
          showProgress(remain/total);
          if (remain !== lastRemain) lastRemain = remain;
          if (remain <= 0) {
            clearTimer();
            finishActions("Time's up!");
          }
        }, 1000);
      };
      setupPauseResume(() => remain, (r) => {
        timer = setInterval(() => {
          if (pauseState.paused) return;
          remain--;
          timerDisplay.textContent = formatTime(remain);
          showProgress(remain/total);
          if (remain <= 0) {
            clearTimer();
            finishActions("Time's up!");
          }
        }, 1000);
      });
    }

    function renderStopwatch() {
      timerControls.innerHTML = '';
      timerControls.classList.add('visible');
      clearTimer();
      hideProgress();
      let elapsed = 0;
      timerDisplay.textContent = '0s';
      const startBtn = document.createElement('button'); startBtn.innerHTML = '<i class="fa fa-play"></i>Start';
      const pauseBtn = document.createElement('button'); pauseBtn.innerHTML = '<i class="fa fa-pause"></i>Pause';
      const resetBtn = document.createElement('button'); resetBtn.innerHTML = '<i class="fa fa-rotate-left"></i>Reset';
      timerControls.append(startBtn, pauseBtn, resetBtn);
      startBtn.onclick = (e) => {
        e.preventDefault();
        clearTimer();
        timer = setInterval(() => { 
          if (pauseState.paused) return;
          timerDisplay.textContent = `${++elapsed}s`;
        }, 1000);
      };
      pauseBtn.onclick = (e) => {
        e.preventDefault();
        pauseState.paused = !pauseState.paused;
        pauseBtn.innerHTML = pauseState.paused ? '<i class="fa fa-play"></i>Resume' : '<i class="fa fa-pause"></i>Pause';
      };
      resetBtn.onclick = (e) => {
        e.preventDefault();
        clearTimer();
        elapsed = 0;
        timerDisplay.textContent = '0s';
      };
    }

    function renderHIIT() {
      timerControls.innerHTML = '';
      timerControls.classList.add('visible');
      clearTimer();
      hideProgress();
      // Work, Rest, Rounds
      const labelW = document.createElement('label'); labelW.textContent = "Work (sec):";
      const work = document.createElement('input'); work.type = "number"; work.min = 1; work.value = 30;
      addIncDec(work, 5, 1);
      const labelR = document.createElement('label'); labelR.textContent = "Rest (sec):";
      const rest = document.createElement('input'); rest.type = "number"; rest.min = 1; rest.value = 10;
      addIncDec(rest, 5, 1);
      const labelN = document.createElement('label'); labelN.textContent = "Rounds:";
      const rounds = document.createElement('input'); rounds.type = "number"; rounds.min = 1; rounds.value = 8;
      addIncDec(rounds, 1, 1);
      const startBtn = document.createElement('button'); startBtn.innerHTML = '<i class="fa fa-play"></i>Start';
      timerControls.append(labelW, work, labelR, rest, labelN, rounds, startBtn);
      let total = 0, remain = 0, current = 1, mode = 'Work';
      startBtn.onclick = (e) => {
        e.preventDefault();
        let w = parseInt(work.value,10), r = parseInt(rest.value,10), n = parseInt(rounds.value,10);
        if ([w, r, n].some(v => isNaN(v) || v < 1))
          return showFeedback('Enter valid positive numbers for work, rest, and rounds.', true);
        showFeedback('');
        total = n * (w + r);
        remain = w;
        current = 1;
        mode = 'Work';
        let roundRemain = w;
        clearTimer();
        showProgress(1.0);
        timerDisplay.textContent = `Round ${current} - ${mode}: ${formatTime(roundRemain)}`;
        timer = setInterval(() => {
          if (pauseState.paused) return;
          showProgress(((n-current)*w + (mode==='Work'?roundRemain:0))/((n*w)));
          roundRemain--;
          timerDisplay.textContent = `Round ${current} - ${mode}: ${formatTime(roundRemain)}`;
          if (roundRemain < 1) {
            if (mode === 'Work') { mode = 'Rest'; roundRemain = r; }
            else if (++current > n) { clearTimer(); finishActions("HIIT complete!"); }
            else { mode = 'Work'; roundRemain = w; }
          }
        }, 1000);
      };
    }

    function renderPomodoro() {
      timerControls.innerHTML = '';
      timerControls.classList.add('visible');
      clearTimer();
      hideProgress();
      const labelW = document.createElement('label'); labelW.textContent = "Work (min):";
      const work = document.createElement('input'); work.type = "number"; work.min = 1; work.value = 25;
      addIncDec(work, 1, 1);
      const labelB = document.createElement('label'); labelB.textContent = "Break (min):";
      const rest = document.createElement('input'); rest.type = "number"; rest.min = 1; rest.value = 5;
      addIncDec(rest, 1, 1);
      const labelN = document.createElement('label'); labelN.textContent = "Rounds:";
      const rounds = document.createElement('input'); rounds.type = "number"; rounds.min = 1; rounds.value = 4;
      addIncDec(rounds, 1, 1);
      const startBtn = document.createElement('button'); startBtn.innerHTML = '<i class="fa fa-play"></i>Start';
      timerControls.append(labelW, work, labelB, rest, labelN, rounds, startBtn);
      let total = 0, remain = 0, current = 1, mode = 'Work';
      startBtn.onclick = (e) => {
        e.preventDefault();
        let w = parseInt(work.value,10)*60, r = parseInt(rest.value,10)*60, n = parseInt(rounds.value,10);
        if ([w, r, n].some(v => isNaN(v) || v < 1))
          return showFeedback('Enter valid positive numbers for work, break, and rounds.', true);
        showFeedback('');
        total = n * (w + r);
        remain = w;
        current = 1;
        mode = 'Work';
        let roundRemain = w;
        clearTimer();
        showProgress(1.0);
        timerDisplay.textContent = `Round ${current} - ${mode}: ${formatTime(roundRemain)}`;
        timer = setInterval(() => {
          if (pauseState.paused) return;
          showProgress(((n-current)*w + (mode==='Work'?roundRemain:0))/((n*w)));
          roundRemain--;
          timerDisplay.textContent = `Round ${current} - ${mode}: ${formatTime(roundRemain)}`;
          if (roundRemain < 1) {
            if (mode === 'Work') { mode = 'Break'; roundRemain = r; }
            else if (++current > n) { clearTimer(); finishActions("Pomodoro complete!"); }
            else { mode = 'Work'; roundRemain = w; }
          }
        }, 1000);
      };
      setupPauseResume(
        () => 0, // For Pomodoro, not supporting accurate remain tracking in pause for now.
        () => { /* restart not supported for Pomodoro */ }
      );
    }

    function renderChess() {
      timerControls.innerHTML = '';
      timerControls.classList.add('visible');
      clearTimer();
      hideProgress();
      // Player times, increments, and start
      const labelA = document.createElement('label'); labelA.textContent = "Player 1 Time (min):";
      const timeA = document.createElement('input'); timeA.type = "number"; timeA.min = 1; timeA.value = 5;
      addIncDec(timeA, 1, 1);
      const labelB = document.createElement('label'); labelB.textContent = "Player 2 Time (min):";
      const timeB = document.createElement('input'); timeB.type = "number"; timeB.min = 1; timeB.value = 5;
      addIncDec(timeB, 1, 1);
      const labelIncr = document.createElement('label'); labelIncr.textContent = "Increment per move (sec):";
      const incr = document.createElement('input'); incr.type = "number"; incr.min = 0; incr.value = 0;
      addIncDec(incr, 1, 0);
      const startBtn = document.createElement('button'); startBtn.innerHTML = '<i class="fa fa-play"></i>Start';
      timerControls.append(labelA, timeA, labelB, timeB, labelIncr, incr, startBtn);
      // For demo: just show settings, not full chess clock logic
      startBtn.onclick = (e) => {
        e.preventDefault();
        showFeedback('Chess clock logic not implemented in demo.', true);
      };
    }

    function renderEvent() {
      timerControls.innerHTML = '';
      timerControls.classList.add('visible');
      clearTimer();
      hideProgress();
      const label = document.createElement('label'); label.textContent = "Event Time (YYYY-MM-DD HH:MM):";
      const input = document.createElement('input'); input.type = "text"; input.placeholder = "2025-12-31 23:59";
      const startBtn = document.createElement('button'); startBtn.innerHTML = '<i class="fa fa-play"></i>Start';
      timerControls.append(label, input, startBtn);
      startBtn.onclick = (e) => {
        e.preventDefault();
        let ts = Date.parse(input.value.replace(' ', 'T'));
        if (isNaN(ts)) return showFeedback('Enter a valid date/time.', true);
        let remain = Math.floor((ts - Date.now())/1000);
        if (remain <= 0) return showFeedback('Event time must be in the future.', true);
        showFeedback('');
        clearTimer();
        showProgress(1.0);
        timer = setInterval(() => {
          if (pauseState.paused) return;
          remain = Math.floor((ts - Date.now())/1000);
          timerDisplay.textContent = formatTime(remain);
          showProgress(remain/(remain+1));
          if (remain <= 0) {
            clearTimer();
            finishActions("Event reached!");
          }
        }, 1000);
      };
    }

    function renderTabata() {
      timerControls.innerHTML = '';
      timerControls.classList.add('visible');
      clearTimer();
      hideProgress();
      // Work, Rest, Rounds
      const labelW = document.createElement('label'); labelW.textContent = "Work (sec):";
      const work = document.createElement('input'); work.type = "number"; work.min = 1; work.value = 20;
      addIncDec(work, 5, 1);
      const labelR = document.createElement('label'); labelR.textContent = "Rest (sec):";
      const rest = document.createElement('input'); rest.type = "number"; rest.min = 1; rest.value = 10;
      addIncDec(rest, 5, 1);
      const labelN = document.createElement('label'); labelN.textContent = "Rounds:";
      const rounds = document.createElement('input'); rounds.type = "number"; rounds.min = 1; rounds.value = 8;
      addIncDec(rounds, 1, 1);
      const startBtn = document.createElement('button'); startBtn.innerHTML = '<i class="fa fa-play"></i>Start';
      timerControls.append(labelW, work, labelR, rest, labelN, rounds, startBtn);
      let total = 0, remain = 0, current = 1, mode = 'Work';
      startBtn.onclick = (e) => {
        e.preventDefault();
        let w = parseInt(work.value,10), r = parseInt(rest.value,10), n = parseInt(rounds.value,10);
        if ([w, r, n].some(v => isNaN(v) || v < 1))
          return showFeedback('Enter valid positive numbers for work, rest, and rounds.', true);
        showFeedback('');
        total = n * (w + r);
        remain = w;
        current = 1;
        mode = 'Work';
        let roundRemain = w;
        clearTimer();
        showProgress(1.0);
        timerDisplay.textContent = `Round ${current} - ${mode}: ${formatTime(roundRemain)}`;
        timer = setInterval(() => {
          if (pauseState.paused) return;
          showProgress(((n-current)*w + (mode==='Work'?roundRemain:0))/((n*w)));
          roundRemain--;
          timerDisplay.textContent = `Round ${current} - ${mode}: ${formatTime(roundRemain)}`;
          if (roundRemain < 1) {
            if (mode === 'Work') { mode = 'Rest'; roundRemain = r; }
            else if (++current > n) { clearTimer(); finishActions("Tabata complete!"); }
            else { mode = 'Work'; roundRemain = w; }
          }
        }, 1000);
      };
    }

    function renderCustom() {
      timerControls.innerHTML = '';
      timerControls.classList.add('visible');
      clearTimer();
      hideProgress();
      const label = document.createElement('label'); label.textContent = "Custom Intervals (comma-separated seconds):";
      const input = document.createElement('input'); input.type = "text"; input.placeholder = "10,20,10";
      const startBtn = document.createElement('button'); startBtn.innerHTML = '<i class="fa fa-play"></i>Start';
      timerControls.append(label, input, startBtn);
      startBtn.onclick = (e) => {
        e.preventDefault();
        let arr = input.value.split(',').map(s=>parseInt(s.trim(),10));
        if (!arr.length || arr.some(v=>isNaN(v)||v<1))
          return showFeedback('Enter positive numbers separated by commas.', true);
        showFeedback('');
        let idx = 0, remain = arr[0];
        clearTimer();
        showProgress(1.0);
        timer = setInterval(() => {
          if (pauseState.paused) return;
          remain--;
          showProgress(remain/arr[idx]);
          timerDisplay.textContent = `Interval ${idx+1}: ${formatTime(remain)}`;
          if (remain <= 0) {
            idx++;
            if (idx >= arr.length) {
              clearTimer();
              finishActions("Custom intervals complete!");
            } else {
              remain = arr[idx];
            }
          }
        }, 1000);
      };
    }

    function renderPresentation() {
      timerControls.innerHTML = '';
      timerControls.classList.add('visible');
      clearTimer();
      hideProgress();
      const label = document.createElement('label'); label.textContent = "Presentation Duration (min):";
      const input = document.createElement('input'); input.type = "number"; input.min = 1; input.value = 10;
      addIncDec(input, 1, 1);
      const startBtn = document.createElement('button'); startBtn.innerHTML = '<i class="fa fa-play"></i>Start';
      timerControls.append(label, input, startBtn);
      startBtn.onclick = (e) => {
        e.preventDefault();
        let mins = parseInt(input.value,10);
        if (isNaN(mins) || mins < 1) return showFeedback('Enter a valid number of minutes.', true);
        let remain = mins * 60, total = remain;
        showFeedback('');
        clearTimer();
        showProgress(1.0);
        timer = setInterval(() => {
          if (pauseState.paused) return;
          remain--;
          showProgress(remain/total);
          timerDisplay.textContent = formatTime(remain);
          if (remain <= 0) {
            clearTimer();
            finishActions("Presentation complete!");
          }
        }, 1000);
      };
    }

    function renderBreathing() {
      timerControls.innerHTML = '';
      timerControls.classList.add('visible');
      clearTimer();
      hideProgress();
      const label = document.createElement('label'); label.textContent = "Cycle (inhale, hold, exhale, hold) in sec (comma):";
      const input = document.createElement('input'); input.type = "text"; input.placeholder = "4,7,8,0";
      const startBtn = document.createElement('button'); startBtn.innerHTML = '<i class="fa fa-play"></i>Start';
      timerControls.append(label, input, startBtn);
      startBtn.onclick = (e) => {
        e.preventDefault();
        let arr = input.value.split(',').map(s=>parseInt(s.trim(),10));
        if (arr.length < 3 || arr.some(v=>isNaN(v)||v<0))
          return showFeedback('Enter at least 3 numbers (inhale, hold, exhale, [hold]).', true);
        showFeedback('');
        let idx = 0, remain = arr[0], phase = ['Inhale','Hold','Exhale','Hold'];
        clearTimer();
        showProgress(1.0);
        timer = setInterval(() => {
          if (pauseState.paused) return;
          remain--;
          showProgress(remain/(arr[idx]||1));
          timerDisplay.textContent = `${phase[idx]}: ${formatTime(remain)}`;
          if (remain <= 0) {
            idx = (idx+1)%arr.length;
            remain = arr[idx];
          }
        }, 1000);
      };
    }

    function renderSoundloop() {
      timerControls.innerHTML = '';
      timerControls.classList.add('visible');
      clearTimer();
      hideProgress();
      const label = document.createElement('label'); label.textContent = "Interval (sec):";
      const input = document.createElement('input'); input.type = "number"; input.min = 1; input.value = 60;
      addIncDec(input, 1, 1);
      const startBtn = document.createElement('button'); startBtn.innerHTML = '<i class="fa fa-play"></i>Start';
      timerControls.append(label, input, startBtn);
      startBtn.onclick = (e) => {
        e.preventDefault();
        let secs = parseInt(input.value,10);
        if (isNaN(secs) || secs < 1) return showFeedback('Enter a valid number of seconds.', true);
        showFeedback('');
        clearTimer();
        showProgress(1.0);
        timer = setInterval(() => {
          if (pauseState.paused) return;
          playBeep();
          vibrate();
          notify('Interval reached!');
        }, secs*1000);
      };
    }

    // --- TIMER MAP ---
    const timerMap = {
      countdown: renderCountdown,
      stopwatch: renderStopwatch,
      hiit: renderHIIT,
      pomodoro: renderPomodoro,
      chess: renderChess,
      event: renderEvent,
      tabata: renderTabata,
      custom: renderCustom,
      presentation: renderPresentation,
      breathing: renderBreathing,
      soundloop: renderSoundloop,
    };

    // --- UNIVERSAL TIMER BOOTSTRAP ---
    timerTypeSelect.addEventListener('change', () => {
      clearTimer();
      timerDisplay.textContent = '';
      timerControls.innerHTML = '';
      feedback.textContent = '';
      timerDisplay.classList.add('visible');
      timerControls.classList.add('visible');
      hideProgress();
      document.getElementById('presetBar').style.display = "none";
      pauseState.paused = false;
      if (!timerTypeSelect.value) {
        timerDisplay.textContent = 'Select a timer type to begin';
        timerControls.classList.remove('visible');
        timerDesc.textContent = '';
        return;
      }
      // Call the right renderer for the timer type
      if (timerMap[timerTypeSelect.value]) timerMap[timerTypeSelect.value]();
    });

    // On page load, show correct description if any selected
    if (timerTypeSelect.value) timerDesc.textContent = timerDescriptions[timerTypeSelect.value] || '';
  </script>
</body>
</html>