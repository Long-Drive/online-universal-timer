<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Universal Timer</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
  <style>
    :root {
      --primary: #0056b3;
      --primary-light: #2176d2;
      --primary-dark: #003f80;
      --background: #f9f9f9;
      --foreground: #222;
      --accent: #c00;
      --success: #080;
      --input-bg: #fff;
      --progress-bg: #e5e5e5;
      --progress-fg: #0056b3;
    }
    [data-theme="dark"] {
      --primary: #90caf9;
      --primary-light: #b6e3ff;
      --primary-dark: #1976d2;
      --background: #181a1b;
      --foreground: #f9f9f9;
      --input-bg: #232323;
      --progress-bg: #282e33;
      --progress-fg: #90caf9;
    }
    html, body {
      background: var(--background);
      color: var(--foreground);
      margin: 0; padding: 0;
      font-family: system-ui, sans-serif;
      height: 100%; min-height: 100vh;
    }
    header {
      background: var(--primary);
      color: #fff;
      padding: 1.2em 0.7em 0.7em 0.7em;
      text-align: center;
      position: relative;
    }
    header h1 { margin: 0; }
    header button {
      background: none;
      border: none;
      color: #fff;
      font-size: 1.3em;
      position: absolute;
      top: 1em;
      right: 1em;
      cursor: pointer;
    }
    main {
      max-width: 400px;
      margin: 2em auto 0 auto;
      background: var(--input-bg);
      border-radius: 10px;
      box-shadow: 0 3px 20px #0001;
      padding: 2em 1.2em 2em 1.2em;
    }
    label {
      display: block;
      margin-bottom: 0.35em;
      font-weight: 600;
    }
    select, input[type="number"], input[type="text"] {
      width: 100%;
      font-size: 1em;
      margin-bottom: 1.2em;
      padding: 0.3em 0.5em;
      border-radius: 6px;
      border: 1px solid #bbb;
      background: var(--input-bg);
      color: var(--foreground);
      box-sizing: border-box;
    }
    button {
      background: var(--primary);
      color: #fff;
      font-size: 1em;
      border: none;
      padding: 0.5em 1.2em;
      border-radius: 6px;
      margin-right: 0.7em;
      margin-top: 1em;
      cursor: pointer;
      transition: background 0.25s;
    }
    button:hover, button:focus {
      background: var(--primary-dark);
    }
    .timer-section {
      margin: 1.3em 0 1.5em 0;
      display: none;
    }
    .timer-section.visible {
      display: block;
    }
    .progress-bar-wrap {
      background: var(--progress-bg);
      border-radius: 6px;
      margin: 1.2em 0 0.5em 0;
      height: 1.2em;
      width: 100%;
      overflow: hidden;
      display: block;
    }
    .progress-bar-inner {
      background: var(--progress-fg);
      height: 100%;
      width: 0;
      transition: width 0.2s;
    }
    .feedback {
      color: var(--accent);
      min-height: 1.2em;
      margin-top: 0.6em;
      font-size: 1em;
      font-weight: 500;
    }
    @media (max-width: 500px) {
      main { padding: 1em 0.4em 2em 0.4em; }
    }
    .incdec-btn {
      border-radius: 50%;
      width: 2em;
      height: 2em;
      border: none;
      background: #d7e8f7;
      color: var(--primary-dark);
      font-size: 1.1em;
      margin: 0 0.25em;
      vertical-align: middle;
    }
    .incdec-btn:hover {
      background: #acd6fa;
    }
    .tooltip {
      border-bottom: 1px dotted var(--primary);
      cursor: help;
      position: relative;
    }
    .tooltip[data-tip]:hover:after {
      content: attr(data-tip);
      position: absolute;
      background: #fff;
      color: #222;
      border: 1px solid #888;
      border-radius: 8px;
      left: 0;
      top: 1.6em;
      white-space: pre;
      padding: 0.5em 0.8em;
      z-index: 50;
      box-shadow: 0 4px 16px #0002;
      font-size: 0.97em;
      min-width: 220px;
      max-width: 350px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Universal Timer</h1>
    <p>Timers for every occasion</p>
    <button id="darkToggle" aria-label="Toggle dark mode" title="Toggle dark/light theme">
      <i class="fa fa-moon"></i>
    </button>
  </header>
  <main>
    <label for="timerType" class="tooltip" data-tip="Choose a timer mode. Hover to see their descriptions.">Select Timer:</label>
    <select id="timerType" aria-label="Timer Type">
      <option value="">-- Select --</option>
      <option value="countdown" data-tip="Simple countdown. Enter a duration and start.">Countdown / Egg Timer</option>
      <option value="stopwatch" data-tip="Counts up from zero.">Stopwatch</option>
      <option value="hiit" data-tip="High-Intensity Interval Training: alternating work/rest intervals for set rounds.">HIIT Interval Timer</option>
      <option value="pomodoro" data-tip="Pomodoro: work/break cycles for productivity.">Pomodoro Timer</option>
      <option value="chess" data-tip="Chess clock: two timers, alternate between players.">Chess Clock</option>
      <option value="event" data-tip="Countdown to a specific date/time.">Event Countdown</option>
      <option value="tabata" data-tip="Tabata: intervals of work and rest for a set number of rounds.">Tabata Timer</option>
      <option value="custom" data-tip="Enter a custom interval pattern, e.g. 10,20,10.">Custom Interval Timer</option>
      <option value="presentation" data-tip="Countdown for presentations with minutes input.">Presentation Timer</option>
      <option value="breathing" data-tip="Guided breathing cycles: inhale, hold, exhale.">Breathing Timer</option>
      <option value="soundloop" data-tip="Repeating sound at set intervals.">Repeating Sound Timer</option>
    </select>
    <span id="timerDesc" style="display:block;min-height:1.8em;margin:0.5em 0 1.2em 0;color:var(--primary-light);font-size:1em;"></span>
    <div id="presetBar"></div>
    <div class="progress-bar-wrap" id="progressWrap" style="display:none;">
      <div class="progress-bar-inner" id="progressInner"></div>
    </div>
    <div id="timerDisplay" class="timer-section visible" role="status" aria-live="polite">Select a timer type to begin</div>
    <form id="timerControls" class="timer-section" aria-label="Timer Controls"></form>
    <div id="feedback" class="feedback" aria-live="polite"></div>
  </main>
  <audio id="beepAudio" src="https://actions.google.com/sounds/v1/alarms/beep_short.ogg" preload="auto"></audio>
  <script>
    // --- THEME TOGGLE ---
    const darkToggle = document.getElementById('darkToggle');
    darkToggle.onclick = () => {
      const html = document.documentElement;
      const newTheme = html.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
      html.setAttribute('data-theme', newTheme);
      darkToggle.innerHTML = newTheme === 'dark' ? '<i class="fa fa-sun"></i>' : '<i class="fa fa-moon"></i>';
      localStorage.setItem('uTimerTheme', newTheme);
    };
    // Persistence
    (() => {
      const t = localStorage.getItem('uTimerTheme');
      if (t) {
        document.documentElement.setAttribute('data-theme', t);
        darkToggle.innerHTML = t === 'dark' ? '<i class="fa fa-sun"></i>' : '<i class="fa fa-moon"></i>';
      }
    })();
    // --- END THEME ---

    // --- TIMER MODE DESCRIPTIONS ---
    const timerDescriptions = {
      countdown: "Simple countdown. Enter minutes and/or seconds.",
      stopwatch: "Counts up from zero. Can pause/resume.",
      hiit: "HIIT: Alternate work/rest intervals for set rounds. Save presets for favorite workouts.",
      pomodoro: "Pomodoro: Work/break cycles for focus. Save favorite settings.",
      chess: "Chess clock: Two timers, alternate between players.",
      event: "Countdown to a specific date/time.",
      tabata: "Tabata: Intervals of work/rest for set rounds.",
      custom: "Custom intervals: e.g. 10,5,10 (seconds per interval).",
      presentation: "Presentation: Countdown for a presentation.",
      breathing: "Guided breathing: inhale, hold, exhale.",
      soundloop: "Repeating sound at set intervals.",
    };

    // --- TOOLTIP ENHANCEMENT ---
    // Show option descriptions as user hovers/selects
    const timerTypeSelect = document.getElementById('timerType');
    const timerDesc = document.getElementById('timerDesc');
    timerTypeSelect.addEventListener('change', () => {
      const val = timerTypeSelect.value;
      timerDesc.textContent = timerDescriptions[val] || '';
    });
    timerTypeSelect.addEventListener('mouseover', e => {
      if (e.target.tagName === 'OPTION') {
        timerDesc.textContent = e.target.dataset.tip || '';
      }
    });
    timerTypeSelect.addEventListener('mouseout', e => {
      const val = timerTypeSelect.value;
      timerDesc.textContent = timerDescriptions[val] || '';
    });

    // --- UTILITY FUNCTIONS ---
    function parseFlexibleTime(str) {
      // Accepts "90" or "1:30" or "2m 15s" or "1m" or "45s"
      str = (str + '').trim();
      if (!str) return NaN;
      if (/^\d+$/.test(str)) return parseInt(str, 10);
      let match = str.match(/^(\d+):(\d+)$/); // "m:s"
      if (match) return parseInt(match[1],10)*60 + parseInt(match[2],10);
      match = str.match(/^(?:(\d+)m)?\s*(?:(\d+)s)?$/i);
      if (match) {
        let m = match[1] ? parseInt(match[1],10) : 0;
        let s = match[2] ? parseInt(match[2],10) : 0;
        return m*60 + s;
      }
      return NaN;
    }
    function formatTime(sec) {
      sec = Math.max(0, Math.floor(sec));
      if (sec >= 60) 
        return `${Math.floor(sec/60)}m ${sec%60}s`;
      return `${sec}s`;
    }
    function playBeep() {
      const beep = document.getElementById('beepAudio');
      if (beep) beep.play();
    }
    function vibrate(ms=300) {
      if (window.navigator && navigator.vibrate) { navigator.vibrate(ms); }
    }
    function notify(msg) {
      if (window.Notification && Notification.permission === "granted") {
        new Notification("Universal Timer", { body: msg, icon: "" });
      }
    }
    (function requestNotificationPermission() {
      if ("Notification" in window && Notification.permission === "default") {
        Notification.requestPermission();
      }
    })();
    function showFeedback(msg, isError = false) {
      feedback.textContent = msg;
      feedback.style.color = isError ? 'var(--accent)' : 'var(--success)';
    }
    function showProgress(ratio) {
      progressWrap.style.display = '';
      progressInner.style.width = `${Math.max(0,Math.min(1,ratio))*100}%`;
    }
    function hideProgress() {
      progressWrap.style.display = 'none';
      progressInner.style.width = '0%';
    }
    function finishActions(msg) {
      playBeep();
      vibrate();
      notify(msg);
      showFeedback(msg, false);
    }

    // --- INC/DEC BUTTONS ---
    function addIncDec(el, step = 1, min = 1, max = 9999) {
      if (!el || el.dataset.incdec) return;
      el.dataset.incdec = "1";
      const wrap = document.createElement('span');
      wrap.style.display = 'inline-flex';
      wrap.style.alignItems = 'center';
      const minus = document.createElement('button');
      minus.type = "button";
      minus.className = 'incdec-btn';
      minus.innerHTML = '<i class="fa fa-minus"></i>';
      minus.onclick = () => {
        let v = parseInt(el.value,10)||0;
        v = Math.max(min, v-step);
        el.value = v;
        el.dispatchEvent(new Event('input', {bubbles:true}));
      };
      const plus = document.createElement('button');
      plus.type = "button";
      plus.className = 'incdec-btn';
      plus.innerHTML = '<i class="fa fa-plus"></i>';
      plus.onclick = () => {
        let v = parseInt(el.value,10)||0;
        v = Math.min(max, v+step);
        el.value = v;
        el.dispatchEvent(new Event('input', {bubbles:true}));
      };
      el.parentNode.insertBefore(wrap, el);
      wrap.appendChild(minus);
      wrap.appendChild(el);
      wrap.appendChild(plus);
    }
    // --- END INC/DEC ---

    // --- UNIVERSAL TIMER LOGIC ---
    const timerDisplay = document.getElementById('timerDisplay');
    const timerControls = document.getElementById('timerControls');
    const feedback = document.getElementById('feedback');
    const progressWrap = document.getElementById('progressWrap');
    const progressInner = document.getElementById('progressInner');
    let timer = null, chess = null;
    let pauseState = { paused: false, remain: 0, context: null };

    function clearTimer() {
      if (timer) clearInterval(timer);
      timer = null;
      hideProgress();
      pauseState.paused = false;
    }
    function setupPauseResume(getRemain, setRemain, onPause, onResume) {
      // getRemain: function returning remaining seconds
      // setRemain: function to set remaining seconds in pause/resume
      const pauseBtn = document.createElement('button');
      pauseBtn.id = "pauseBtn";
      pauseBtn.innerHTML = '<i class="fa fa-pause"></i> Pause';
      pauseBtn.onclick = () => {
        if (!pauseState.paused) {
          clearInterval(timer);
          pauseState.paused = true;
          pauseState.remain = getRemain();
          pauseBtn.innerHTML = '<i class="fa fa-play"></i> Resume';
          if (onPause) onPause();
        } else {
          pauseState.paused = false;
          setRemain(pauseState.remain);
          pauseBtn.innerHTML = '<i class="fa fa-pause"></i> Pause';
          if (onResume) onResume();
        }
      };
      timerControls.appendChild(pauseBtn);
    }

    // --- TIMER RENDERERS ---
    function renderCountdown() {
      timerControls.innerHTML = '';
      clearTimer();
      hideProgress();
      const label = document.createElement('label'); label.textContent = "Duration (e.g. 1:30 or 90s):";
      const input = document.createElement('input'); input.type = "text"; input.placeholder = "e.g. 90, 1:30, 2m 15s";
      addIncDec(input, 5, 1);
      const startBtn = document.createElement('button'); startBtn.innerHTML = '<i class="fa fa-play"></i>Start';
      timerControls.append(label, input, startBtn);
      let total = 0, remain = 0;
      startBtn.onclick = (e) => {
        e.preventDefault();
        let time = parseFlexibleTime(input.value);
        if (isNaN(time) || time < 1) return showFeedback('Please enter a valid time.', true);
        showFeedback('');
        total = time; remain = time;
        clearTimer();
        let lastRemain = remain;
        timerDisplay.textContent = formatTime(remain);
        showProgress(1.0);
        timer = setInterval(() => {
          if (pauseState.paused) return;
          remain--;
          timerDisplay.textContent = formatTime(remain);
          showProgress(remain/total);
          if (remain !== lastRemain) lastRemain = remain;
          if (remain <= 0) {
            clearTimer();
            finishActions("Time's up!");
          }
        }, 1000);
      };
      setupPauseResume(() => remain, (r) => {
        timer = setInterval(() => {
          if (pauseState.paused) return;
          remain--;
          timerDisplay.textContent = formatTime(remain);
          showProgress(remain/total);
          if (remain <= 0) {
            clearTimer();
            finishActions("Time's up!");
          }
        }, 1000);
      });
    }

    function renderStopwatch() {
      timerControls.innerHTML = '';
      clearTimer();
      hideProgress();
      let elapsed = 0;
      timerDisplay.textContent = '0s';
      const startBtn = document.createElement('button'); startBtn.innerHTML = '<i class="fa fa-play"></i>Start';
      const pauseBtn = document.createElement('button'); pauseBtn.innerHTML = '<i class="fa fa-pause"></i>Pause';
      const resetBtn = document.createElement('button'); resetBtn.innerHTML = '<i class="fa fa-rotate-left"></i>Reset';
      timerControls.append(startBtn, pauseBtn, resetBtn);
      startBtn.onclick = (e) => {
        e.preventDefault();
        clearTimer();
        timer = setInterval(() => { 
          if (pauseState.paused) return;
          timerDisplay.textContent = `${++elapsed}s`;
        }, 1000);
      };
      pauseBtn.onclick = (e) => {
        e.preventDefault();
        pauseState.paused = !pauseState.paused;
        pauseBtn.innerHTML = pauseState.paused ? '<i class="fa fa-play"></i>Resume' : '<i class="fa fa-pause"></i>Pause';
      };
      resetBtn.onclick = (e) => {
        e.preventDefault();
        clearTimer();
        elapsed = 0;
        timerDisplay.textContent = '0s';
      };
    }

    function renderHIIT() {
      timerControls.innerHTML = '';
      clearTimer();
      hideProgress();
      // Work, Rest, Rounds
      const labelW = document.createElement('label'); labelW.textContent = "Work (sec):";
      const work = document.createElement('input'); work.type = "number"; work.min = 1; work.value = 20;
      addIncDec(work, 5, 1);
      const labelR = document.createElement('label'); labelR.textContent = "Rest (sec):";
      const rest = document.createElement('input'); rest.type = "number"; rest.min = 1; rest.value = 10;
      addIncDec(rest, 5, 1);
      const labelN = document.createElement('label'); labelN.textContent = "Rounds:";
      const rounds = document.createElement('input'); rounds.type = "number"; rounds.min = 1; rounds.value = 8;
      addIncDec(rounds, 1, 1);
      const startBtn = document.createElement('button'); startBtn.innerHTML = '<i class="fa fa-play"></i>Start';
      timerControls.append(labelW, work, labelR, rest, labelN, rounds, startBtn);
      let total = 0, remain = 0, current = 1, mode = 'Work';
      startBtn.onclick = (e) => {
        e.preventDefault();
        let w = parseInt(work.value,10), r = parseInt(rest.value,10), n = parseInt(rounds.value,10);
        if ([w, r, n].some(v => isNaN(v) || v < 1))
          return showFeedback('Enter valid positive numbers for work, rest, and rounds.', true);
        showFeedback('');
        total = n * (w + r);
        remain = w;
        current = 1;
        mode = 'Work';
        let roundRemain = w;
        clearTimer();
        showProgress(1.0);
        timerDisplay.textContent = `Round ${current} - ${mode}: ${formatTime(roundRemain)}`;
        timer = setInterval(() => {
          if (pauseState.paused) return;
          showProgress(((n-current)*w + (mode==='Work'?roundRemain:0))/((n*w)));
          roundRemain--;
          timerDisplay.textContent = `Round ${current} - ${mode}: ${formatTime(roundRemain)}`;
          if (roundRemain < 1) {
            if (mode === 'Work') { mode = 'Rest'; roundRemain = r; }
            else if (++current > n) { clearTimer(); finishActions("HIIT complete!"); }
            else { mode = 'Work'; roundRemain = w; }
          }
        }, 1000);
      };
      setupPauseResume(
        () => 0, // For HIIT, not supporting accurate remain tracking in pause for now.
        () => { /* restart not supported for HIIT */ }
      );
    }

    function renderPomodoro() {
      timerControls.innerHTML = '';
      clearTimer();
      hideProgress();
      const labelW = document.createElement('label'); labelW.textContent = "Work (min):";
      const work = document.createElement('input'); work.type = "number"; work.min = 1; work.value = 25;
      addIncDec(work, 1, 1);
      const labelB = document.createElement('label'); labelB.textContent = "Break (min):";
      const rest = document.createElement('input'); rest.type = "number"; rest.min = 1; rest.value = 5;
      addIncDec(rest, 1, 1);
      const labelN = document.createElement('label'); labelN.textContent = "Rounds:";
      const rounds = document.createElement('input'); rounds.type = "number"; rounds.min = 1; rounds.value = 4;
      addIncDec(rounds, 1, 1);
      const startBtn = document.createElement('button'); startBtn.innerHTML = '<i class="fa fa-play"></i>Start';
      timerControls.append(labelW, work, labelB, rest, labelN, rounds, startBtn);
      let total = 0, remain = 0, current = 1, mode = 'Work';
      startBtn.onclick = (e) => {
        e.preventDefault();
        let w = parseInt(work.value,10)*60, r = parseInt(rest.value,10)*60, n = parseInt(rounds.value,10);
        if ([w, r, n].some(v => isNaN(v) || v < 1))
          return showFeedback('Enter valid positive numbers for work, break, and rounds.', true);
        showFeedback('');
        total = n * (w + r);
        remain = w;
        current = 1;
        mode = 'Work';
        let roundRemain = w;
        clearTimer();
        showProgress(1.0);
        timerDisplay.textContent = `Round ${current} - ${mode}: ${formatTime(roundRemain)}`;
        timer = setInterval(() => {
          if (pauseState.paused) return;
          showProgress(((n-current)*w + (mode==='Work'?roundRemain:0))/((n*w)));
          roundRemain--;
          timerDisplay.textContent = `Round ${current} - ${mode}: ${formatTime(roundRemain)}`;
          if (roundRemain < 1) {
            if (mode === 'Work') { mode = 'Break'; roundRemain = r; }
            else if (++current > n) { clearTimer(); finishActions("Pomodoro complete!"); }
            else { mode = 'Work'; roundRemain = w; }
          }
        }, 1000);
      };
      setupPauseResume(
        () => 0, // For Pomodoro, not supporting accurate remain tracking in pause for now.
        () => { /* restart not supported for Pomodoro */ }
      );
    }

    function renderChess() {
      timerControls.innerHTML = '';
      clearTimer();
      hideProgress();
      // Player times, increments, and start
      const labelA = document.createElement('label'); labelA.textContent = "Player 1 Time (min):";
      const timeA = document.createElement('input'); timeA.type = "number"; timeA.min = 1; timeA.value = 5;
      addIncDec(timeA, 1, 1);
      const labelB = document.createElement('label'); labelB.textContent = "Player 2 Time (min):";
      const timeB = document.createElement('input'); timeB.type = "number"; timeB.min = 1; timeB.value = 5;
      addIncDec(timeB, 1, 1);
      const labelIncr = document.createElement('label'); labelIncr.textContent = "Increment per move (sec):";
      const incr = document.createElement('input'); incr.type = "number"; incr.min = 0; incr.value = 0;
      addIncDec(incr, 1, 0);
      const startBtn = document.createElement('button'); startBtn.innerHTML = '<i class="fa fa-play"></i>Start';
      timerControls.append(labelA, timeA, labelB, timeB, labelIncr, incr, startBtn);
      // For demo: just show settings, not full chess clock logic
      startBtn.onclick = (e) => {
        e.preventDefault();
        showFeedback('Chess clock logic not implemented in demo.', true);
      };
    }

    function renderEvent() {
      timerControls.innerHTML = '';
      clearTimer();
      hideProgress();
      const label = document.createElement('label'); label.textContent = "Event Time (YYYY-MM-DD HH:MM):";
      const input = document.createElement('input'); input.type = "text"; input.placeholder = "2025-12-31 23:59";
      const startBtn = document.createElement('button'); startBtn.innerHTML = '<i class="fa fa-play"></i>Start';
      timerControls.append(label, input, startBtn);
      startBtn.onclick = (e) => {
        e.preventDefault();
        let ts = Date.parse(input.value.replace(' ', 'T'));
        if (isNaN(ts)) return showFeedback('Enter a valid date/time.', true);
        let remain = Math.floor((ts - Date.now())/1000);
        if (remain <= 0) return showFeedback('Event time must be in the future.', true);
        showFeedback('');
        clearTimer();
        showProgress(1.0);
        timer = setInterval(() => {
          if (pauseState.paused) return;
          remain = Math.floor((ts - Date.now())/1000);
          timerDisplay.textContent = formatTime(remain);
          showProgress(remain/(remain+1));
          if (remain <= 0) {
            clearTimer();
            finishActions("Event reached!");
          }
        }, 1000);
      };
    }

    function renderTabata() {
      timerControls.innerHTML = '';
      clearTimer();
      hideProgress();
      // Work, Rest, Rounds
      const labelW = document.createElement('label'); labelW.textContent = "Work (sec):";
      const work = document.createElement('input'); work.type = "number"; work.min = 1; work.value = 20;
      addIncDec(work, 5, 1);
      const labelR = document.createElement('label'); labelR.textContent = "Rest (sec):";
      const rest = document.createElement('input'); rest.type = "number"; rest.min = 1; rest.value = 10;
      addIncDec(rest, 5, 1);
      const labelN = document.createElement('label'); labelN.textContent = "Rounds:";
      const rounds = document.createElement('input'); rounds.type = "number"; rounds.min = 1; rounds.value = 8;
      addIncDec(rounds, 1, 1);
      const startBtn = document.createElement('button'); startBtn.innerHTML = '<i class="fa fa-play"></i>Start';
      timerControls.append(labelW, work, labelR, rest, labelN, rounds, startBtn);
      let total = 0, remain = 0, current = 1, mode = 'Work';
      startBtn.onclick = (e) => {
        e.preventDefault();
        let w = parseInt(work.value,10), r = parseInt(rest.value,10), n = parseInt(rounds.value,10);
        if ([w, r, n].some(v => isNaN(v) || v < 1))
          return showFeedback('Enter valid positive numbers for work, rest, and rounds.', true);
        showFeedback('');
        total = n * (w + r);
        remain = w;
        current = 1;
        mode = 'Work';
        let roundRemain = w;
        clearTimer();
        showProgress(1.0);
        timerDisplay.textContent = `Round ${current} - ${mode}: ${formatTime(roundRemain)}`;
        timer = setInterval(() => {
          if (pauseState.paused) return;
          showProgress(((n-current)*w + (mode==='Work'?roundRemain:0))/((n*w)));
          roundRemain--;
          timerDisplay.textContent = `Round ${current} - ${mode}: ${formatTime(roundRemain)}`;
          if (roundRemain < 1) {
            if (mode === 'Work') { mode = 'Rest'; roundRemain = r; }
            else if (++current > n) { clearTimer(); finishActions("Tabata complete!"); }
            else { mode = 'Work'; roundRemain = w; }
          }
        }, 1000);
      };
    }

    function renderCustom() {
      timerControls.innerHTML = '';
      clearTimer();
      hideProgress();
      const label = document.createElement('label'); label.textContent = "Custom Intervals (comma-separated seconds):";
      const input = document.createElement('input'); input.type = "text"; input.placeholder = "10,20,10";
      const startBtn = document.createElement('button'); startBtn.innerHTML = '<i class="fa fa-play"></i>Start';
      timerControls.append(label, input, startBtn);
      startBtn.onclick = (e) => {
        e.preventDefault();
        let arr = input.value.split(',').map(s=>parseInt(s.trim(),10));
        if (!arr.length || arr.some(v=>isNaN(v)||v<1))
          return showFeedback('Enter positive numbers separated by commas.', true);
        showFeedback('');
        let idx = 0, remain = arr[0];
        clearTimer();
        showProgress(1.0);
        timer = setInterval(() => {
          if (pauseState.paused) return;
          remain--;
          showProgress(remain/arr[idx]);
          timerDisplay.textContent = `Interval ${idx+1}: ${formatTime(remain)}`;
          if (remain <= 0) {
            idx++;
            if (idx >= arr.length) {
              clearTimer();
              finishActions("Custom intervals complete!");
            } else {
              remain = arr[idx];
            }
          }
        }, 1000);
      };
    }

    function renderPresentation() {
      timerControls.innerHTML = '';
      clearTimer();
      hideProgress();
      const label = document.createElement('label'); label.textContent = "Presentation Duration (min):";
      const input = document.createElement('input'); input.type = "number"; input.min = 1; input.value = 10;
      addIncDec(input, 1, 1);
      const startBtn = document.createElement('button'); startBtn.innerHTML = '<i class="fa fa-play"></i>Start';
      timerControls.append(label, input, startBtn);
      startBtn.onclick = (e) => {
        e.preventDefault();
        let mins = parseInt(input.value,10);
        if (isNaN(mins) || mins < 1) return showFeedback('Enter a valid number of minutes.', true);
        let remain = mins * 60, total = remain;
        showFeedback('');
        clearTimer();
        showProgress(1.0);
        timer = setInterval(() => {
          if (pauseState.paused) return;
          remain--;
          showProgress(remain/total);
          timerDisplay.textContent = formatTime(remain);
          if (remain <= 0) {
            clearTimer();
            finishActions("Presentation complete!");
          }
        }, 1000);
      };
    }

    function renderBreathing() {
      timerControls.innerHTML = '';
      clearTimer();
      hideProgress();
      const label = document.createElement('label'); label.textContent = "Cycle (inhale, hold, exhale, hold) in sec (comma):";
      const input = document.createElement('input'); input.type = "text"; input.placeholder = "4,7,8,0";
      const startBtn = document.createElement('button'); startBtn.innerHTML = '<i class="fa fa-play"></i>Start';
      timerControls.append(label, input, startBtn);
      startBtn.onclick = (e) => {
        e.preventDefault();
        let arr = input.value.split(',').map(s=>parseInt(s.trim(),10));
        if (arr.length < 3 || arr.some(v=>isNaN(v)||v<0))
          return showFeedback('Enter at least 3 numbers (inhale, hold, exhale, [hold]).', true);
        showFeedback('');
        let idx = 0, remain = arr[0], phase = ['Inhale','Hold','Exhale','Hold'];
        clearTimer();
        showProgress(1.0);
        timer = setInterval(() => {
          if (pauseState.paused) return;
          remain--;
          showProgress(remain/(arr[idx]||1));
          timerDisplay.textContent = `${phase[idx]}: ${formatTime(remain)}`;
          if (remain <= 0) {
            idx = (idx+1)%arr.length;
            remain = arr[idx];
          }
        }, 1000);
      };
    }

    function renderSoundloop() {
      timerControls.innerHTML = '';
      clearTimer();
      hideProgress();
      const label = document.createElement('label'); label.textContent = "Interval (sec):";
      const input = document.createElement('input'); input.type = "number"; input.min = 1; input.value = 60;
      addIncDec(input, 1, 1);
      const startBtn = document.createElement('button'); startBtn.innerHTML = '<i class="fa fa-play"></i>Start';
      timerControls.append(label, input, startBtn);
      startBtn.onclick = (e) => {
        e.preventDefault();
        let secs = parseInt(input.value,10);
        if (isNaN(secs) || secs < 1) return showFeedback('Enter a valid number of seconds.', true);
        showFeedback('');
        clearTimer();
        showProgress(1.0);
        timer = setInterval(() => {
          if (pauseState.paused) return;
          playBeep();
          vibrate();
          notify('Interval reached!');
        }, secs*1000);
      };
    }

    // --- TIMER MAP ---
    const timerMap = {
      countdown: renderCountdown,
      stopwatch: renderStopwatch,
      hiit: renderHIIT,
      pomodoro: renderPomodoro,
      chess: renderChess,
      event: renderEvent,
      tabata: renderTabata,
      custom: renderCustom,
      presentation: renderPresentation,
      breathing: renderBreathing,
      soundloop: renderSoundloop,
    };

    // --- UNIVERSAL TIMER BOOTSTRAP ---
    timerTypeSelect.addEventListener('change', () => {
      clearTimer();
      timerDisplay.textContent = '';
      timerControls.innerHTML = '';
      feedback.textContent = '';
      timerDisplay.classList.add('visible');
      timerControls.classList.add('visible');
      hideProgress();
      document.getElementById('presetBar').style.display = "none";
      pauseState.paused = false;
      if (!timerTypeSelect.value) {
        timerDisplay.textContent = 'Select a timer type to begin';
        timerControls.classList.remove('visible');
        timerDesc.textContent = '';
        return;
      }
      // Call the right renderer for the timer type
      if (timerMap[timerTypeSelect.value]) timerMap[timerTypeSelect.value]();
      timerDesc.textContent = timerDescriptions[timerTypeSelect.value] || '';
    });
    // On page load, show correct description if any selected
    if (timerTypeSelect.value) timerDesc.textContent = timerDescriptions[timerTypeSelect.value] || '';
  </script>
</body>
</html>